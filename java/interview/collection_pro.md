## *Структуры данных и алгоритмы*

- [Что такое generics?](#1-что-такое-generics)
- [Что такое wild cards?](#2-что-такое-wild-cards)
- [Что такое bounded wild cards?](#3-что-такое-bounded-wild-cards)
- [Что такое unbounded wild cards?](#4-что-такое-unbounded-wild-cards)
- [Где хранится информация про Generics?](#5-где-хранится-информация-про-generics)
- [Как можно получить тип Generics?](#6-как-можно-получить-тип-generics)
- [Что такое итератор? В чем разница между itetator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница?  Когда возникает ConcurrentModificationException?](#7-что-такое-итератор-в-чем-разница-между-itetator-и-listiterator-что-такое-fail-fast-и-fail-safe-поведение-итератора-и-в-чем-между-ними-разница-когда-возникает-concurrentmodificationexception)
- [Что такое коллекции?](#8-что-такое-коллекции)
- [Назовите базовые интерфейсы коллекций?](#9-назовите-базовые-интерфейсы-коллекций)
- [Расскажите реализации интерфейса List?](#10-расскажите-реализации-интерфейса-list)
- [Расскажите реализации интерфейса Set?](#11-расскажите-реализации-интерфейса-set)
- [Расскажите реализации интерфейса Map?](#12-расскажите-реализации-интерфейса-map)
- [Отличие ArrayList от LinkedList?](#13-отличие-arraylist-от-linkedlist)
- [Отличие Set от List?](#14-отличие-set-от-list)
- [Расскажите про методы Object hashCode и equals?](#15-расскажите-про-методы-object-hashcode-и-equals)
- [Расскажите, что такое коллизии в Map? Как с ними бороться?](#16-расскажите-что-такое-коллизии-в-map-как-с-ними-бороться)
- [Расскажите, что такое анализ алгоритма?](#17-расскажите-что-такое-анализ-алгоритма)
- [Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#18-какая-временная-сложность-алгоритмовo-нотация-добавления-замены-и-удаления-в-каждой-из-коллекций-с-чем-связаны-----отличия)
- [Расскажите реализации данных очередей и стеков.](#19-расскажите-реализации-данных-очередей-и-стеков)
- [Расскажите про реализации деревьев.](#20-расскажите-про-реализации-деревьев)
- [Что такое loadFactor?](#21-что-такое-loadfactor)
- [Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.](#22-перечислите-побитовые-логические-операции-которые-вы-знаете-расскажите-как-они-работают)
- [Расскажите про операции сдвига. Какие они бывают и что делают?](#23-расскажите-про-операции-сдвига-какие-они-бывают-и-что-делают)
- [Как хранится знак числа в Java? Как хранятся отрицательные числа?](#24-как-хранится-знак-числа-в-java-как-хранятся-отрицательные-числа)
- [Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle ?](#25-расскажите-о-системах-сборки-проекта-в-чем-отличие-систем-сборки-ant-maven-и-gradle-)
- [Как создать maven - проект?](#26-как-создать-maven---проект)
- [Какова структура maven-проекта?](#27-какова-структура-maven-проекта)
- [Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?](#28-расскажите-о-файле-pomxml-как-он-структурирован-и-за-что-отвечает-содержание-каждой-части)
- [Что такое координаты зависимости? ](#29-что-такое-координаты-зависимости)
- [Что такое транзитивные зависимости?](#30-что-такое-транзитивные-зависимости)
- [Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?](#31-что-такое-область-видимости-зависимости-сколько-областей-видимости-предусмотрено-и-где-они-применяются)
- [Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?](#32-расскажите-о-жизненном-цикле-maven-в-какой-последовательности-выполняются-фазы-цикла-и-что-происходит-на-каждой-фазе-сборки)

---

### 1. Что такое generics?
Generics — это механизм параметризации типов, позволяющий писать классы, интерфейсы и методы, работающие с разными типами данных, сохраняя строгую типизацию на этапе компиляции.
```java
public class GenericClass<T> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
```
В Java вся информация о дженериках стирается во время компиляции.
```java
public class GenericClass<T> {
    private T value;

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }
}
После стирания T заменяется границами (bounds) или Object.
public class GenericClass {
    private Object value;

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }
}
```

Свойства дженериков: строгая типизация, единая реализация, отсутствие информации о типе.

Существует 2 типа дженериков:

+ ```<Т>``` Обычные дженерики (параметризованные типы) - представляет возможность указать в классе или методе неопределенный тип или несколько типов, дать ему имя, которое в дальнейшем можно использовать в рамках класса или метода, как эквивалентное оригинальному типу.
Может быть использован с ключевым словом ```extends```, ограничен этим классом и его наследниками. Так же можно использовать ```&``` и```/```или ```|``` указать несколько классов и/или интерфейсов. Поддерживает рекурсивное расширение типов.
```java
public static class NumberContainer<T extends Number & Comparable> {
}
```

+ ```<?>``` Wildcard (подстановочные типы или маски) - используются в сигнатуре методов, но для параметризации класса - нет! Может быть использован в сочитании ключевыми словами ```extends``` и ```super```. Делятся на три типа: 

+	Upper Bounded Wildcards ```<? extends Number>```
+	Unbounded Wildcards ```<?>```
+	Lower Bounded Wildcards ```<? super Integer>```

Для выбора типа используют принцип *PECS* (Producer Extends Consumer Super)
+	extends - когда надо только получать данные из объекта. Метод передает данные в аргумент.

Producer – extends
```java
void printNumbers(List<? extends Number> list) {
    for (Number n : list) {
        System.out.println(n);
    }
    // list.add(10); НЕЛЬЗЯ может быть List<Double> будет попытка Int засунуть
}
List<Integer> ints = List.of(1, 2, 3);
printNumbers(ints);
```
+	super - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.

Consumer — super
```java
void addIntegers(List<? super Integer> list) {
    list.add(10);
    list.add(20);
    // Integer x = list.get(0); нельзя
    Object o = list.get(0);    
}
List<Number> nums = new ArrayList<>();
addIntegers(nums);
```
+	не использовать wildcard, когда требуется и получать и вставлять данные в структуру.
### 2. Что такое wild cards?
Wildcard ```<?>``` — это подстановочный тип в generics, означающий “неизвестный тип”. Он используется только в сигнатурах (параметрах методов, полях, переменных), но не при объявлении классов.

    List<?> list

### 3. Что такое bounded wild cards?
Bounded wildcard — это wildcard ```<? extends>``` с ограничением типа.

Ограничение задаёт верхнюю границу допустимых типов.

Используется, когда нужно работать не с любым типом, а только с определённым классом и его иерархией.

```java
List<? extends Number> // список Number или любой наследник
```
```<? extends T> → чтения T``` - методах используется для чтения.
### 4. Что такое unbounded wild cards?
Bounded wildcard — это wildcard ```<? super>``` с ограничением типа снизу.

```java
List<? super Number> // список Number или любой родитель
list.add(10);      // Integer — подтип Number, OK
list.add(3.14);    // Double — подтип Number, OK

Object obj = list.get(0); // OK, читаем как Object
// Number n = list.get(0); // Ошибка! Тип точно неизвестен
```
```<? super T> → пишем T``` - методах используется для записи.

### 5. Где хранится информация про Generics?
Информация о generics хранится только на этапе компиляции. В Java используется type erasure (стирание типов): компилятор заменяет все generic-типы на их bounds (по умолчанию Object) и добавляет casts где нужно. В байт-коде (runtime) generics не существуют — все становится сырыми типами (raw types).

Где именно:
+	В исходном коде: В .java файлах.
+	В скомпилированном коде: В .class файлах сохраняется сигнатура generics в метаданных (attribute "Signature" в байт-коде), но не в исполняемом коде. Это позволяет рефлексии (Reflection API) получить информацию о generics.
+	На runtime: Нет, из-за type erasure. list.getClass() для ArrayList<String> вернет class java.util.ArrayList, без <String>.

Нюансы:
+	Type erasure обеспечивает обратную совместимость с кодом до Java 5.
+	Исключения: Generic-методы и классы сохраняют info в метаданных для рефлексии.
+	Пример: ParameterizedType в Reflection.
### 6. Как можно получить тип Generics?
Получить тип generics на runtime можно только через Reflection API, используя классы вроде ParameterizedType, GenericArrayType и т.д. Прямой доступ невозможен из-за type erasure, но метаданные в .class сохраняются.
```java
public class TestClass {
    class MyClass extends OtherClass<GenericClass>{
        String myName;
        //Whatever
    }
    class OtherClass<T> {
        T myfield;
    }
    class GenericClass {
        String field;
    }

    public static void main(String[] args){
        OtherClass<GenericClass> ttt = new MyClass();
        ParameterizedType t = (ParameterizedType) ttt.getClass().getGenericSuperclass();
        Class<?> cls = (Class<?>) t.getActualTypeArguments()[0]; //
        System.out.println(cls);  // напечатает TestClass#GenericClass
    }
}

public class GetGenericType {
    static class GenericClass<T> {
        List<T> list = new ArrayList<>();
    }
    public static void main(String[] args) throws NoSuchFieldException {
        GenericClass<String> instance = new GenericClass<>();
        Type type = instance.getClass().getDeclaredField("list").getGenericType();
        if (type instanceof ParameterizedType) {
            ParameterizedType pType = (ParameterizedType) type;
            Type[] actualArgs = pType.getActualTypeArguments();
            System.out.println(actualArgs[0]); // class java.lang.String
        }
    }
}
```
Через анонимный подкласс
```java
List<String> list = new ArrayList<>() {}; // Анонимный класс
ParameterizedType pType = (ParameterizedType) list.getClass().getGenericSuperclass();
Type arg = pType.getActualTypeArguments()[0]; // String
```

+ Работает только для полей, методов, суперклассов с сохраненными generics.
+ Для локальных переменных info теряется.
+ Не работает для стертых типов или если generics не указаны.

### 7. Что такое итератор? В чем разница между itetator и listIterator? Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница?  Когда возникает ConcurrentModificationException?
Это шаблон проектирования для прохода по всем элементам множества, в java реализован с помощью объекта Iterator.

Основные методы:
+	hasNext() - существует ли следующий элемент.
+	next() - возвращает сам элемет.

В стандартной библиотеке java существует 2 интерфейса это Iterable и Iterator.
+	Iterable - вынуждает релизовать метод возвращающий итератор.
+	Iterator - вернуть объект итератора.

Реализация интератора https://github.com/WhiteVax/job4j_design/blob/master/src/main/java/ru/job4j/iterator/NonNullIterator.java

Разница между itetator и listIterator.

| Характеристика           | Iterator                    | ListIterator                                 |
| ------------------------ | --------------------------- | -------------------------------------------- |
| Доступные коллекции      | Подходит для всех коллекций | Только List                                  |
| Движение                 | Только вперёд               | Вперёд и назад                               |
| Методы навигации         | hasNext(), next()           | hasNext(), next(), hasPrevious(), previous() |
| Манипуляции с коллекцией | remove()                    | add(E e), remove(), set(E e)                 |
| Итерация с позиции       | Всегда с первого элемента   | Можно начинать с произвольной позиции        |

```java
ListIterator<String> lit = list.listIterator();
lit.next();
lit.set("New");
```

Что такое fail-fast и fail-safe поведение итератора и в чем между ними разница?

+ Fail-fast поведение: Итераторы, которые выбрасывают ConcurrentModificationException при обнаружении структурных изменений коллекции (add/remove) вне итератора во время итерации. Итераторы ArrayList, HashMap (modCount проверка)
+ Fail-safe поведение: Итераторы, которые не выбрасывают исключения при модификациях, а работают с копией или позволяют изменения. Итераторы ConcurrentHashMap, CopyOnWriteArrayList.

| Характеристика                 | Fail-Fast                                     | Fail-Safe                               |
| ------------------------------ | --------------------------------------------- | --------------------------------------- |
| Реакция на изменение коллекции | Выбрасывает `ConcurrentModificationException` | Работает без ошибки                     |
| Как работает                   | Следит за `modCount`, проверяет изменения     | Работает с копией данных                |
| Производительность             | Быстрее (нет лишних копий)                    | Медленнее (из-за копирования)           |
| Где используется               | ArrayList, HashSet, HashMap                   | CopyOnWriteArrayList, ConcurrentHashMap |
| Видит изменения коллекции      | Да                                            | Нет                                     |
| Разница                        | Если коллекция меняется — выбрасывает CME     | Работает с копией, изменения не видит   |

Когда возникает ConcurrentModificationException?

Когда коллекция модифицируется структурно (не через итератор) во время итерации fail-fast итератором.
```java
while(iterator.hasNext()) {
            if (iterator.next() == 1) {
            //    list.remove(1); ConcurrentModificationException
                iterator.remove();
            }
        }

for (String s : list) { // Использует Iterator внутри
    list.add("New"); // Exception
}
```

### 8. Что такое коллекции?
«Коллекция» - это структура данных, набор каких-либо объектов. Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.


Базовые интерфейсы Collections Framework

| Интерфейс      | Назначение                                                               |
| -------------- | ------------------------------------------------------------------------ |
| **Collection** | Базовый интерфейс для всех коллекций (List, Set)                         |
| **List**       | Упорядоченный набор элементов, допускает дубликаты                       |
| **Set**        | Набор уникальных элементов                                               |
| **Queue**      | Коллекция для обработки элементов по принципу FIFO (очередь)             |
| **Deque**      | Двусторонняя очередь (можно добавлять/удалять с обоих концов)            |
| **Map**        | Отображение ключ → значение (не является Collection, но часть Framework) |

### 9. Назовите базовые интерфейсы коллекций?

### 10. Расскажите реализации интерфейса List?

### 11. Расскажите реализации интерфейса Set?

### 12. Расскажите реализации интерфейса Map?

### 13. Отличие ArrayList от LinkedList?

### 14. Отличие Set от List?

### 15. Расскажите про методы Object hashCode и equals?

### 17. Расскажите, что такое анализ алгоритма?

### 16. Расскажите, что такое коллизии в Map? Как с ними бороться?

### 18. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны     отличия?

### 19. Расскажите реализации данных очередей и стеков.

### 20. Расскажите про реализации деревьев.

### 21. Что такое loadFactor?

### 22. Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

### 23. Расскажите про операции сдвига. Какие они бывают и что делают?

### 24. Как хранится знак числа в Java? Как хранятся отрицательные числа?

### 25. Расскажите о системах сборки проекта. В чем отличие систем сборки Ant, Maven и Gradle ?

### 26. Как создать maven - проект?

### 27. Какова структура maven-проекта?

### 28. Расскажите о файле pom.xml. Как он структурирован и за что отвечает содержание каждой части?

### 29. Что такое координаты зависимости?

### 30. Что такое транзитивные зависимости?

### 31. Что такое область видимости зависимости? Сколько областей видимости предусмотрено и где они применяются?

### 32. Расскажите о жизненном цикле maven. В какой последовательности выполняются фазы цикла и что происходит на каждой фазе сборки?