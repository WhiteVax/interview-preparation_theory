## *Collection lite*

- [Что такое "коллекция".](#1-что-такое-коллекция)
- [Перечислите основные методы из интерфейса java.util.Collection. Назовите преимущества использования коллекций по сравнению с массивами.](#2-назовите-преимущества-использования-коллекций-по-сравнению-с-массивами)
- [Какие данные могут хранить коллекции?](#3-какие-данные-могут-хранить-коллекции)
- [Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.](#4-какие-есть-типы-коллекций-как-они-характеризуются-расскажите-про-иерархию-коллекций-list-set-map)
- [Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.](#5-назовите-основные-классы-которые-имплементируютреализуют-интерфейсы-list-set-map)
- [В чём отличие ArrayList от LinkedList?](#6-в-чём-отличие-arraylist-от-linkedlist)
- [В чём отличие HashSet от TreeSet?](#7-в-чём-отличие-hashset-от-treeset)
- [В чём отличие Set от Map?](#8-в-чём-отличие-set-от-map)
- [Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?](#9-как-задается-порядок-следования-объектов-в-коллекции-как-отсортировать-коллекцию)
- [Чем отличается Comparable от Comparator?](#10-чем-отличается-comparable-от-comparator)
- [Что такое сортировка по принципу Natural Order?](#11-что-такое-сортировка-по-принципу-natural-order)
- [Что такое equals и hashcode?](#12-что-такое-equals-и-hashcode)
- [Какие есть способы перебора всех элементов List?](#13-какие-есть-способы-перебора-всех-элементов-list)
- [Расскажите об основных методах Map.](#14-расскажите-об-основных-методах-map)
- [Расскажите, какие классы реализовывают интерфейс Map?](#15-расскажите-какие-классы-реализовывают-интерфейс-map)
- [Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#16-расскажите-о-методах-mapkeyset-и-mapentryset-что-такое-entry)
- [Что будет если вызвать метод map.put несколько раз с одинаковым ключом?](#17-что-будет-если-вызвать-метод-mapput-несколько-раз-с-одинаковым-ключом)
- [Как реализован цикл foreach?](#18-как-реализован-цикл-foreach)
- [В чем разница между Iterator и Iterable?](#19-в-чем-разница-между-iterator-и-iterable)
- [Как происходит удаление элементов из ArrayList?](#20-как-происходит-удаление-элементов-из-arraylist)
- [Как происходит удаление элементов из LinkedList?](#21-как-происходит-удаление-элементов-из-linkedlist)
- [Что такое автоупаковка и распаковка? Зачем они нужны?](#22-что-такое-автоупаковка-и-распаковка-зачем-они-нужны)
- [В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?](#23-в-каком-случае-при-работе-с-упакованными-значениями-может-возникнуть-проблема-с-производительностью)
- [Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.](#24-опишите-недостатки-и-преимущества-в-использовании-примитивных-типов-и-классов-оберток)
- [Что такое очередь? Расскажите принцип работы и для чего она используется.](#25-что-такое-очередь-расскажите-принцип-работы-и-для-чего-она-используется)
- [Расскажите про интерфейсы Queue, Deque и их иерархию.](#26-расскажите-про-интерфейсы-queue-deque-и-их-иерархию)
- [В чем отличие метода poll() от remove()?](#27-в-чем-отличие-метода-poll-от-remove)
- [В чем отличие метода element() от peek()?](#28-в-чем-отличие-метода-element-от-peek)
- [В чем отличие метода element() от poll()?](#29-в-чем-отличие-метода-element-от-poll)
- [Перечислите наиболее часто используемые реализации интерфейса Queue.](#30-перечислите-наиболее-часто-используемые-реализации-интерфейса-queue)
- [Что такое ограниченные и неограниченные очереди?](#31-что-такое-ограниченные-и-неограниченные-очереди)
- [Что такой односторонние и двусторонние очереди?](#32-что-такой-односторонние-и-двусторонние-очереди)
- [В чём отличие Deque от Queue?](#33-в-чём-отличие-deque-от-queue)
- [В чём отличие методов removeLast() и pollLast()?](#34-в-чём-отличие-методов-removelast-и-polllast)
- [Назовите самую распространенную реализацию Deque.](#35-назовите-самую-распространенную-реализацию-deque)

---

### 1. Что такое "коллекция".
Коллекция — это объект, предназначенный для хранения и управления группой других объектов (элементов).
+ Коллекции позволяют:
    +	хранить наборы данных (числа, строки, объекты пользовательских классов),
    +	динамически добавлять, удалять и искать элементы,
    +	работать с данными удобнее и безопаснее, чем с массивами.
### 1.1. Перечислите основные методы из интерфейса java.util.Collection.
| Группа | Метод | Описание |
|------|------|---------|
| Добавление | `add(E e)` | Добавляет элемент в коллекцию |
| Добавление | `addAll(Collection<? extends E> c)` | Добавляет все элементы из другой коллекции |
| Удаление | `remove(Object o)` | Удаляет указанный элемент |
| Удаление | `removeAll(Collection<?> c)` | Удаляет все элементы, содержащиеся в другой коллекции |
| Удаление | `retainAll(Collection<?> c)` | Оставляет только элементы, содержащиеся в другой коллекции |
| Удаление | `clear()` | Удаляет все элементы из коллекции |
| Проверка | `contains(Object o)` | Проверяет, содержится ли элемент в коллекции |
| Проверка | `containsAll(Collection<?> c)` | Проверяет, содержит ли коллекция все элементы другой |
| Проверка | `isEmpty()` | Проверяет, пуста ли коллекция |
| Проверка | `size()` | Возвращает количество элементов |
| Обход | `iterator()` | Возвращает итератор для обхода элементов |
| Обход | `forEach(Consumer<? super E> action)` | Выполняет действие для каждого элемента (Java 8+) |
| Преобразование | `toArray()` | Возвращает массив элементов |
| Преобразование | `toArray(T[] a)` | Возвращает массив указанного типа |

### 2. Назовите преимущества использования коллекций по сравнению с массивами.
+	Динамический размер — нет необходимости заранее задавать и вручную контролировать размер коллекции;
+	Богатый API — предоставляют готовые методы для добавления, удаления, поиска, сортировки и обработки элементов;
+	Повышение производительности — при правильном выборе реализации коллекции можно добиться более эффективной работы программы;
+	Универсальность — служат стандартным способом хранения и передачи данных между различными частями приложения;
+	Поддержка обобщений (generics) — обеспечивают безопасность типов во время компиляции;
+  Удобный обход элементов — поддержка итераторов, for-each, Stream API.
### 3. Какие данные могут хранить коллекции?
Коллекции в Java могут хранить только ссылочные типы данных (объекты).

**Это могут быть**:
+	объекты стандартных классов (String, Integer, LocalDate и т.д.),
+	объекты пользовательских классов,
+	объекты-обёртки над примитивами (Integer, Double, Boolean и др.).

### 4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.
<p align="center">
  <img src="imgs-collection/collection-core.png" width="400" height="300" alt="Compile process">
</p>
В основе Java Collections Framework лежит интерфейс Iterable, который содержит один метод:
        
    Iterator<T> iterator();

+ Интерфейс Collection расширяет Iterable и является базовым интерфейсом для большинства коллекций.
    + Все коллекции, реализующие Collection, можно перебирать с помощью for-each.
      + Итератор — это объект, реализующий паттерн Iterator, который предоставляет единый способ последовательного доступа к элементам коллекции без знания её внутренней структуры.

Основные типы коллекций
1. List — упорядоченная коллекция

Характеристики:
+ сохраняет порядок добавления элементов;
+ допускает дубликаты;
+ поддерживает доступ по индексу.

**Основные реализации**:

ArrayList
+ основан на динамическом массиве;
+ быстрый доступ по индексу (O(1));
+ медленные вставки и удаления в середине списка.

LinkedList
+ двусвязный список;
+ быстрые вставки и удаления;
+ медленный доступ по индексу.

Vector
+ устаревшая потокобезопасная реализация List;
+ методы синхронизированы.

Stack
+ наследуется от Vector;
+ реализует стек (LIFO);
+ считается устаревшим, рекомендуется Deque.

2. Set — коллекция уникальных элементов
   Характеристики:
   не допускает дубликатов;
   порядок хранения зависит от реализации.

**Основные реализации**:

HashSet
+ основан на HashMap;
+ порядок элементов не гарантируется.

LinkedHashSet
+ сохраняет порядок добавления элементов.

TreeSet
+ хранит элементы в отсортированном виде;
+ использует natural ordering или Comparator;
+ основан на красно-чёрном дереве.

3. Queue / Deque — очереди

Queue

Предназначена для обработки элементов в порядке FIFO (first-in-first-out).

PriorityQueue
+ элементы извлекаются по приоритету;
+ порядок задаётся Comparator или естественным порядком.

Deque (двусторонняя очередь)
+ Расширяет Queue, позволяет работать как с FIFO, так и с LIFO.

ArrayDeque
+ замена Stack;
+ эффективная реализация очереди и стека.

**Map — ассоциативная коллекция (НЕ наследуется от Collection)**

Map хранит данные в виде пар ключ–значение.

Характеристики:
+ ключи уникальны;
+ значения могут повторяться.

Основные реализации:

HashMap
+ неупорядоченная хэш-таблица;
+ допускает один null-ключ и null-значения.

LinkedHashMap
+ сохраняет порядок вставки.

TreeMap
+ отсортированная карта;
+ использует Comparator или natural ordering;
+ основана на красно-чёрном дереве.

Hashtable
+ устаревшая синхронизированная реализация;
+ не допускает null.

WeakHashMap
+ ключи хранятся как weak references;
+ элементы удаляются GC при отсутствии жёстких ссылок на ключ.

### 5. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.
+	List: ArrayList, LinkedList
+	Set: HashSet, LinkedHashSet, TreeSet
+	Map: HashMap, LinkedHashMap, TreeMap

### 6. В чём отличие ArrayList от LinkedList?
ArrayList реализован на массивах. (используют если чаще читаются элементы, чем добавляются) Хранит свои элементы в массиве.
+ осуществляется быстрый поиск элементов.
+ меньше расходует памяти на хранение элементов
- увеличение ArrayList'a происходит медленно.
- при вставке элемента (или удалении) в середину или в начало, приходится переписывать все элементы.

LinkedList является представителем двунаправленного списка. (цепочка) (используется если элементы чаще добавляются чем читаются) Хранит свои элементы в объектах у которых есть ссылки на предыдущий и следующий элементы.
+ быстрая вставка и удаление в середину списка (переписать next и prev и всё)
- долгий поиск в середине (нужно перебрать все элементы)
Используется когда преобладает удаление или вставка в начало или конец списка.

### 7. В чём отличие HashSet от TreeSet?
+	HashSet хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
+	TreeSet хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

### 8. В чём отличие Set от Map?
|Характеристика	|Set|Map|
|---|---|---|
|Структура|Хранит только значения.|Хранит пары "ключ-значение".|
|Уникальность|Все элементы уникальны.|Ключи уникальны, значения могут повторяться.|
|Доступ|Нет доступа по индексу или ключу.|Доступ к значению по ключу.|
|Порядок элементов|Зависи от реализации (HashSet, TreeSet).|Зависи от реализации (HashMap, TreeMap).|
Обе коллекции используются для разных задач: Set удобен, когда нужно хранить уникальные элементы, а Map — когда необходимо связывать ключи с данными.

### 9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
Порядок элементов в Java-коллекциях может определяться:

+	Порядком вставки (например ArrayList, LinkedList, LinkedHashSet, LinkedHashMap)
+	Естественным порядком (natural order) — если элементы реализуют Comparable
+	Пользовательским компаратором — через Comparator
+	Не гарантирован — у хеш-коллекций (HashSet, HashMap)

Если элементы реализуют Comparable:
```java
Collections.sort(collection);
```
или (начиная с Java 8):
```java
collection.sort(null);
```
Если нужен свой порядок — используем Comparator:
```collection.sort(new MyComparator());```
или:
```Collections.sort(collection, new MyComparator());```
Сортировать можно только списки (List).

Set и Map напрямую не сортируются — для этого их нужно преобразовать в List или использовать TreeSet / TreeMap.

| Коллекция | Порядок элементов | Сортировка |
|----------|------------------|-----------|
| ArrayList | Порядок вставки | Через `Collections.sort()` или `List.sort()` |
| LinkedList | Порядок вставки | Через `Collections.sort()` |
| HashSet | Не гарантирован | Не поддерживает |
| LinkedHashSet | Порядок вставки | Не поддерживает |
| TreeSet | Отсортирован автоматически | Natural order или `Comparator` |
| HashMap | Не гарантирован | Не поддерживает |
| LinkedHashMap | Порядок вставки | Не поддерживает |
| TreeMap | Отсортирован по ключам | Natural order или `Comparator` |

### 10. Чем отличается Comparable от Comparator?

| Критерий | Comparable | Comparator |
|---------|-----------|-----------|
| Где реализуется | Внутри самого класса | В отдельном классе |
| Назначение | Определяет *естественный порядок* объектов | Определяет *пользовательский порядок* |
| Требует изменения класса | Да | Нет |
| Основной метод | `compareTo(T o)` | `compare(T o1, T o2)` |
| Количество вариантов сортировки | Один | Сколько угодно |
| Когда применяется | По умолчанию при сортировке | Передаётся явно |

Разница:

+ Comparable определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации и, если нет доступа к исходникам, ее невозможно изменить.
+ Comparator позволает определить логику сравнения объектов определенного ссылочного типа вне реализации этого типа и эту логику можно в любой момент подменить.
Comparable используется для natural ordering, а Comparator для total ordering.

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int compareTo(Person other) {
        return Integer.compare(this.age, other.age); // Сравнение по возрасту
    }
}
// Использование:
List<Person> people = new ArrayList<>();
people.add(new Person("Alice", 30));
people.add(new Person("Bob", 25));
Collections.sort(people); // Сортировка по возрасту

А теперь с comparator
public class AgeComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return Integer.compare(p1.getAge(), p2.getAge());
    }
}

public class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
}

// Использование:
List<Person> people = new ArrayList<>();
people.add(new Person("Alice", 30));
people.add(new Person("Bob", 25));

// Сортировка по возрасту:
Collections.sort(people, new AgeComparator());

// Сортировка по имени:
Collections.sort(people, new NameComparator());
```

### 11. Что такое сортировка по принципу Natural Order?
Некоторые классы из коробки реализуют естественный порядок natural order для сортировки:
+	строки - лексикографический (по алфавиту),
+	числа - числовой, знаковый или без (больше меньше),
+	дата - хронологичский (по датам),
+	файл - лексикографический по имени пути
+	boolean - false < true
+ 
Где используется Natural Order
1.	TreeSet и TreeMap: Элементы автоматически упорядочиваются в естественном порядке, если не задан Comparator.
2.	Collections.sort и Arrays.sort: Если объект реализует Comparable, методы сортируют по естественному порядку.
3.	Stream API: Использование метода sorted() без Comparator подразумевает естественный порядок.
### 12. Что такое equals и hashcode?
Методы, необходимые для определения равенства объектов.

hashcode возвращает число, являющееся уникальным идентификатором объекта. Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества. Алгоритм вычисления хеш-кода не идеальный и ограничен числовым типом int, поэтому после сравнения по хеш коду объекты сравниваются с помощью equals.

equals сравнивает объекты по значению их полей.

Объекты всех коллекций в названии которых есть Hash... должны иметь hashcode и equals.
### 13. Какие есть способы перебора всех элементов List?
```java
for (int i = 0; i < list.size(); i++) {
    System.out.println(list.get(i));
}
        
for (String element : list) {
    System.out.println(element);
}
        
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
String element = iterator.next();
    System.out.println(element);
}

Доступен только для списков, поддерживает итерацию в обоих направлениях.
ListIterator<String> listIterator = list.listIterator();
while (listIterator.hasNext()) {
        System.out.println(listIterator.next());
        }

// Итерация в обратном порядке
while (listIterator.hasPrevious()) {
        System.out.println(listIterator.previous());
        }
        
list.forEach(element -> System.out.println(element));

// Ссылка на метод
list.forEach(System.out::println);

list.stream().forEach(System.out::println);

// С фильтрацией
list.stream()
    .filter(element -> element.startsWith("A"))
        .forEach(System.out::println);

int i = 0;
while (i < list.size()) {
        System.out.println(list.get(i));
i++;
        }

        Устаревший метод, используется с Vector.
Vector<String> vector = new Vector<>(list);
Enumeration<String> enumeration = vector.elements();

while (enumeration.hasMoreElements()) {
        System.out.println(enumeration.nextElement());
        }
```
### 14. Расскажите об основных методах Map.
+	void clear(): очищает коллекцию
+	boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
+	boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
+	Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
+	boolean equals(Object obj): возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj
+	boolean isEmpty: возвращает true, если коллекция пуста
+	V get(Object k): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
+	V getOrDefault(Object k, V defaultValue): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение defaultVlue
+	V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
+	V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
+	Set<K> keySet(): возвращает набор всех ключей отображения
+	Collection<V> values(): возвращает набор всех значений отображения
+	void putAll(Map<? extends K, ? extends V> map): добавляет в коллекцию все объекты из отображения map
+	V remove(Object k): удаляет объект с ключом k
+	int size(): возвращает количество элементов коллекции

### 15. Расскажите, какие классы реализовывают интерфейс Map?
HashMap

+ Описание: Хэш-таблица для хранения данных. Обеспечивает быстрый доступ к элементам за счет использования хэш-функции.
  + Особенности:
    +	Неупорядоченный: порядок элементов не гарантируется.
    +	Разрешение коллизий: используется метод цепочек (связных списков или деревьев для улучшения производительности (когда кол-во эл. бакете больше 6-8*)).
    +	Позволяет один null-ключ и множество null-значений.
    +	В среднем время доступа к элементу — O(1).
    
LinkedHashMap
    
+ Описание: Подкласс HashMap, который сохраняет порядок вставки элементов.
  + Особенности:
    +	Упорядоченный: элементы возвращаются в порядке вставки.
    +	Немного медленнее, чем HashMap, из-за поддержания порядка.
    +	Подходит, когда важен порядок элементов.
    
TreeMap

+ Описание: Реализация Map на основе красно-черного дерева. 
  + Особенности:
      +	Сортированный: ключи отсортированы в естественном порядке (Comparable) или в соответствии с переданным компаратором.
      +	Время доступа к элементам — O(log(n)).
      +	Не допускает null-ключей, но допускает null-значения.
      +	Подходит, когда требуется доступ к отсортированным данным.
    
Hashtable

+ Описание: Устаревший класс, замененный HashMap. Потокобезопасная версия хэш-таблицы.
    + Особенности:
      +	Синхронизированная: подходит для многопоточных приложений, но медленнее, чем HashMap.
      +	Не допускает null-ключей или null-значений.
      +	Рекомендуется использовать более современные классы, такие как ConcurrentHashMap
    
EnumMap

+ Описание: Карта, где ключами могут быть только значения перечислений (Enum).
  + Особенности:
    + Высокая производительность, так как использует массивы для хранения данных.
    + Ключи обязаны быть типом Enum, значения могут быть любыми.
    + Подходит для случаев, когда в качестве ключей используются перечисления.
   
```
enum Day { MONDAY, TUESDAY, WEDNESDAY }
Map<Day, String> enumMap = new EnumMap<>(Day.class);
enumMap.put(Day.MONDAY, "Start of week");
enumMap.put(Day.TUESDAY, "Second day");
```

ConcurrentHashMap

+ Описание: Потокобезопасная версия HashMap для многопоточных приложений.
  + Особенности:
    +	Высокая производительность: блокировка выполняется на отдельных сегментах карты, а не на всей карте.
    +	Не допускает null-ключей или null-значений.
    +	Подходит для многопоточных программ с высокой конкурентностью.
    
WeakHashMap

+ Описание: Использует слабые ссылки на ключи, что позволяет сборщику мусора удалять объекты, которые больше не используются.
  + Особенности:
  +	Ключи могут быть удалены автоматически, если на них больше нет сильных ссылок.
  +	Подходит для реализации кэшей.
  
IdentityHashMap

+ Описание: Использует сравнение ссылок (==) вместо метода equals для определения равенства ключей.
  + Особенности:
  +	Подходит для специализированных задач, где требуется учитывать только идентичность объектов.
  +	Производительность может быть выше, чем у HashMap, из-за отсутствия вызовов equals.

| Класс             | Порядок      | Сложность | Потокобезопасен | Null-ключ |
| ----------------- | ------------ | --------- | --------------- | --------- |
| HashMap           | Нет          | O(1)      | Нет             | Да        |
| LinkedHashMap     | Вставки      | O(1)      | Нет             | Да        |
| TreeMap           | Отсортирован | O(log n)  | Нет             | Нет       |
| Hashtable         | Нет          | O(1)      | Да              | Нет       |
| EnumMap           | Enum порядок | O(1)      | Нет             | Нет       |
| ConcurrentHashMap | Нет          | O(1)      | Да              | Нет       |
| WeakHashMap       | Нет          | O(1)      | Нет             | Да        |
| IdentityHashMap   | Нет          | O(1)      | Нет             | Да        |

Рекомендации по выбору
1.	HashMap: Используйте по умолчанию для большинства задач.
2.	LinkedHashMap: Когда важен порядок вставки.
3.	TreeMap: Если требуется сортировка по ключам.
4.	ConcurrentHashMap: Для многопоточных программ.
5.	WeakHashMap: При использовании слабых ссылок (например, для кэшей).
6.	IdentityHashMap: Для задач, где важно сравнение ссылок (==).

### 16. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?
Метод map.keySet()

+ Описание: Возвращает Set, содержащий все ключи карты.
  + Особенности:
    +	Коллекция ключей связана с оригинальной картой. Любые изменения в этой коллекции отражаются на карте и наоборот.
    +	Порядок ключей зависит от реализации карты (HashMap, TreeMap и т.д.).
    +	Позволяет итерироваться только по ключам, что эффективно, если значения не нужны.
    +	Удаление через keySet: Можно удалить ключ напрямую через keySet, что автоматически удаляет соответствующую пару из карты.
```java  
keys.remove("Alice"); // Удаляет "Alice" из карты
System.out.println(map); // Вывод: {Bob=25}
```

Метод map.entrySet()

+ Описание: Возвращает Set<Map.Entry<K, V>>, содержащий все пары "ключ-значение" карты.
  + Особенности:
    + Каждый элемент набора представлен объектом типа Map.Entry.
    + Позволяет работать с парами "ключ-значение" одновременно, а не только с ключами или значениями.
    + Изменения в entrySet также влияют на оригинальную карту.

```java
Set<Map.Entry<String, Integer>> entries = map.entrySet();
for (Map.Entry<String, Integer> entry : entries) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}
```
Удаление через entrySet: 

Можно удалить элементы карты, итерируясь по entrySet.
```java
entries.removeIf(entry -> entry.getValue() < 30); // Удаляет элементы с value < 30
System.out.println(map); // Вывод: {Alice=30}
```

Map.Entry
+ Описание: Map.Entry — это статический вложенный интерфейс внутри Map, представляющий пару "ключ-значение".
  + Основные методы Map.Entry:
    + K getKey(): Возвращает ключ текущей пары.
    + V getValue(): Возвращает значение текущей пары.
    + V setValue(V value): Изменяет значение текущей пары (отражается на карте).
```java
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    System.out.println("Key: " + entry.getKey());
    System.out.println("Value: " + entry.getValue());

    // Изменение значения через `setValue`
    if (entry.getKey().equals("Alice")) {
        entry.setValue(35);
    }
}
System.out.println(map); // Вывод: {Alice=35, Bob=25}
```
| Метод        | Возвращает            | Когда применять             |
| ------------ | --------------------- | --------------------------- |
| `keySet()`   | `Set<K>`              | Когда нужны только ключи    |
| `entrySet()` | `Set<Map.Entry<K,V>>` | Когда нужны ключ + значение |

Используйте keySet, если необходимо просто перечислить ключи или проверить их наличие.

Используйте entrySet, если нужно манипулировать парами "ключ-значение" или изменять значения напрямую.
### 17. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?
В Java метод map.put(key, value) позволяет добавить пару "ключ-значение" в коллекцию Map. Если ключ уже существует в карте, то старое значение для этого ключа будет заменено новым.
Если ключ уже существует:
•	Старое значение, связанное с этим ключом, заменяется новым значением.
•	Метод возвращает старое значение для указанного ключа.
•	Если это первый вызов для данного ключа, возвращается null.
Если ключ отсутствует:
•	Пара "ключ-значение" добавляется в карту.
•	Метод возвращает null.
Используйте put, если хотите перезаписывать значение для ключа.
Если требуется вставка только при отсутствии ключа, отдавайте предпочтение putIfAbsent.

### 18. Как реализован цикл foreach?
Когда используете foreach для массива, компилятор преобразует цикл в обычный индексированный цикл for.
```java
int[] array = {1, 2, 3};
for (int num : array) {
    System.out.println(num);
}
Компилируется в:
for (int i = 0; i < array.length; i++) {
    int num = array[i];
    System.out.println(num);
}
        Для коллекций (например, List, Set)
Когда foreach применяется к коллекции, компилятор использует итератор для перебора элементов. Коллекции в Java обычно реализуют интерфейс Iterable, который предоставляет метод iterator().
List<Integer> list = List.of(1, 2, 3);
for (int num : list) {
    System.out.println(num);
}
Компилируется в 
Iterator<Integer> iterator = list.iterator();
while (iterator.hasNext()) {
    int num = iterator.next();
    System.out.println(num);
}
Реализация интерфейса Iterable
Для работы foreach объект должен реализовывать интерфейс Iterable. Этот интерфейс требует реализации метода iterator(), который возвращает объект, реализующий интерфейс Iterator
public interface Iterable<T> {
    Iterator<T> iterator();
}
public interface Iterator<E> {
    boolean hasNext(); // Проверяет, есть ли следующий элемент
    E next();          // Возвращает следующий элемент
    default void remove() { // (Необязательно) Удаляет текущий элемент
        throw new UnsupportedOperationException("remove");
    }
}
Если хотите, чтобы ваш класс работал с foreach, нужно реализовать Iterable и создать свой итератор:
import java.util.Iterator;

public class MyCollection implements Iterable<String> {
    private String[] items = {"Alice", "Bob", "Charlie"};

    @Override
    public Iterator<String> iterator() {
        return new Iterator<>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < items.length;
            }

            @Override
            public String next() {
                return items[index++];
            }
        };
    }

    public static void main(String[] args) {
        MyCollection collection = new MyCollection();
        for (String item : collection) {
            System.out.println(item);
        }
    }
}
```
Цикл foreach в Java преобразуется в вызов методов iterator() и перебор с помощью hasNext() и next() для коллекций или в индексированный цикл для массивов.

### 19. В чем разница между Iterator и Iterable?
Iterable

+ Описание:
  + Это интерфейс, представляющий коллекцию, которую можно перебрать.
    +	Коллекции, реализующие Iterable, предоставляют метод iterator(), возвращающий объект типа Iterator.
    +	Цель: Предоставить коллекции возможность быть использованной в цикле foreach.
    +	Основной метод:
    +	```Iterator<T> iterator(): Возвращает объект Iterator```, который можно использовать для перебора элементов.
    +	Ключевая особенность: Сам Iterable не предоставляет методов для прямого перебора элементов. Он только возвращает итератор.
```java
public class MyCollection implements Iterable<String> {
    private String[] items = {"Alice", "Bob", "Charlie"};

    @Override
    public Iterator<String> iterator() {
        return new Iterator<>() {
            private int index = 0;

            @Override
            public boolean hasNext() {
                return index < items.length;
            }

            @Override
            public String next() {
                return items[index++];
            }
        };
    }
}

public class Main {
    public static void main(String[] args) {
        MyCollection collection = new MyCollection();
        for (String item : collection) { // Использование foreach
            System.out.println(item);
        }
    }
}
```
Iterator
+ Описание:
  +	Это интерфейс, представляющий объект, который выполняет перебор элементов коллекции.
  +	Предоставляет методы для пошагового доступа к элементам коллекции.
  +	Цель: Предоставить способ поэлементного доступа к данным в коллекции.
  +	Основные методы:
  +	```boolean hasNext()```: Проверяет, есть ли следующий элемент.
  +	```E next()```: Возвращает следующий элемент.
  +	```void remove()``` (опциональный): Удаляет текущий элемент (необязательная операция, может быть не поддержана).
  +	Ключевая особенность: Работает с одной конкретной коллекцией, которую он перебирает.
```java
while (iterator.hasNext()) {
            String item = iterator.next();
            System.out.println(item);

```
### 20. Как происходит удаление элементов из ArrayList?
Основные способы удаления (ArrayList динамический массив)

```remove(int index)``` - удаляет элемент по индексу.
```java
list.remove(2);
```
Особенности:

+ Все элементы справа сдвигаются влево
+ Размер списка уменьшается на 1
+ Может выбросить IndexOutOfBoundsException
+ Сложность: O(n)

```remove(Object o)``` - удаляет первое вхождение объекта.
```java
list.remove("Bob");
```

clear() Полностью очищает список.
```java
list.clear();
```

```removeIf(Predicate<? super E> filter)``` - удаляет элементы по условию.
```java
list.removeIf(num -> num < 25);
```

Удаление диапазона через subList - ```list.subList(1, 3).clear();```  удаляет элементы с 1 по 2
```Iterator.remove()``` — безопасное удаление при обходе
```java
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    if (it.next() < 10) {
        it.remove();
    }
}
```
**Что происходит при удалении элемента?**

1. Сдвиг элементов
+ Если элемент удаляется не с конца:
  + Все элементы справа сдвигаются на одну позицию влево
    + Поэтому удаление из середины — O(n)

2. Обнуление ссылки
+ Удалённая ячейка становится null, чтобы GC мог освободить память:
```java
es[size] = null;
```

3. Обновление размера
```java
size--;
```

4. Под капотом (remove(int index))
+ Фрагмент из OpenJDK:
```java
System.arraycopy(es, i + 1, es, i, newSize - i);
es[size = newSize] = null;
```

+ System.arraycopy сдвигает массив
+ size уменьшается
+ последний элемент обнуляется

| Метод               | Описание                         |
| ------------------- | -------------------------------- |
| `remove(int)`       | Удаление по индексу              |
| `remove(Object)`    | Удаление первого совпадения      |
| `clear()`           | Очистка всего списка             |
| `removeIf()`        | Удаление по условию              |
| `Iterator.remove()` | Безопасное удаление при итерации |
| `subList().clear()` | Удаление диапазона               |

| Операция             | Сложность |
| -------------------- | --------- |
| Удаление с конца     | O(1)      |
| Удаление из середины | O(n)      |
| Удаление с начала    | O(n)      |


### 21. Как происходит удаление элементов из LinkedList?
LinkedList внутри

+ LinkedList — это двусвязный список.
  + Каждый элемент (узел) содержит:
    + значение (item)
    + ссылку на предыдущий узел (prev)
    + ссылку на следующий узел (next)

```java
prev ← Node ←→ Node ←→ Node → next
```

+ Удаление элемента
  + prev.next указывает на next
  + next.prev указывает на prev
  + Удаляемый узел выпадает из цепочки.
```java
 A <-> B <-> C
``` 
  Удаляем B:
```java
A <-> C
```
Под капотом
```java
prev.next = next;
next.prev = prev;
item = null;
```
| Метод                 | Описание                                          |
| --------------------- | ------------------------------------------------- |
| `remove(int index)`   | Удаляет элемент по индексу, перенастраивая ссылки |
| `remove(Object o)`    | Удаляет первое вхождение объекта                  |
| `removeFirst()`       | Удаляет первый элемент                            |
| `removeLast()`        | Удаляет последний элемент                         |
| `removeIf(Predicate)` | Удаляет элементы по условию                       |
| `clear()`             | Очищает весь список                               |
| `Iterator.remove()`   | Безопасное удаление при итерации                  |
### 22. Что такое автоупаковка и распаковка? Зачем они нужны?
Автоупаковка (Autoboxing) и распаковка (Unboxing) — это механизм в Java, который автоматически преобразует примитивные типы данных в их соответствующие классы-обёртки и обратно.

Этот процесс был введён в Java 5 для упрощения работы с примитивами и их классами-обёртками, особенно в контексте коллекций и других объектов, которые требуют использование ссылочных типов.
+ Автоупаковка:
  + Компилятор преобразует запись Integer boxedInt = 5; в Integer boxedInt = Integer.valueOf(5);.
  + Метод valueOf использует кэширование для часто используемых значений (например, от -128 до 127 для Integer).
+ Распаковка:
  +	Компилятор преобразует запись int primitiveInt = boxedInt; в int primitiveInt = boxedInt.intValue();
### 23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?
| Причина                          | Описание                                                                       | Решение                                                    |
| -------------------------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------- |
| **Лишние объекты**               | Автоупаковка создаёт новые объекты → нагрузка на heap → частые GC              | Использовать примитивы (`int`, `long`)                     |
| **Ограничения кэширования**      | Кэшируется только диапазон `-128..127`. За пределами — создаются новые объекты | Учитывать диапазон, избегать массового создания `Integer`  |
| **Упаковка/распаковка в циклах** | Частые вызовы `valueOf()`, `intValue()` и т.п. дают накладные расходы          | Использовать примитивы или primitive-стримы                |
| **NullPointerException**         | Распаковка `null` вызывает `NPE`                                               | Проверять `null` перед распаковкой                         |
| **Общее снижение скорости**      | Wrapper-типы медленнее примитивов, особенно в вычислениях                      | Использовать `IntStream`, `LongStream`, массивы примитивов |
```java
Integer sum = 0;

for (int i = 0; i < 1_000_000; i++) {
    sum += i;   
    // sum распаковывается в int, выполняется сложение, 
    // результат снова упаковывается в Integer, создаётся новый объект, каждой итерации
}
```
### 24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
Примитивные типы — это базовые типы данных, не являющиеся объектами. Они обладают высокой производительностью, так как не требуют дополнительных операций (например, создания объектов в куче).

Примеры примитивных типов:
+	byte, short, int, long — для целых чисел.
+	float, double — для чисел с плавающей точкой.
+	char — для символов.
+	boolean — для логических значений.
Преимущества примитивных типов:
1.	Высокая производительность:
      +	Примитивы хранятся в стеке, что делает операции с ними быстрее.
      +	Нет накладных расходов на создание объектов и управление памятью.
2.	Меньший объём памяти:
      +	Примитивы занимают меньше памяти по сравнению с объектами.
      +	Например, int занимает 4 байта, тогда как Integer требует дополнительной памяти для хранения объекта.
3.	Простота и прямолинейность:
      +	Примитивы легко использовать, так как они не имеют методов и работают "напрямую".
        + Классы-обёртки — это объекты, которые "оборачивают" примитивные типы. Они позволяют использовать примитивы как объекты.
        
        Примеры классов-обёрток:
        +	Byte, Short, Integer, Long — для целых чисел.
        +	Float, Double — для чисел с плавающей точкой.
        +	Character — для символов.
        +	Boolean — для логических значений.
       
Преимущества классов-обёрток:
1.	Могут использоваться в коллекциях:
      +	Коллекции, такие как List<Integer> или Map<String, Double>, принимают объекты.
2.	Поддерживают null:
      +	Классы-обёртки могут содержать null, что удобно для обозначения отсутствующего значения.
3.	Предоставляют методы:
      +	Например, Integer имеет методы toString(), parseInt() и т.д.
4.	Унификация работы с объектами:
      +	Упрощают взаимодействие с API, которые принимают только объекты.
### 25. Что такое очередь? Расскажите принцип работы и для чего она используется.
Очередь (Queue) — это линейная структура данных, работающая по принципу FIFO (First In, First Out). Элемент, добавленный в очередь первым, будет извлечён из неё первым.

Очередь основанная на ```<Node>``` узлах, которые хранят значение и в зависимости от двунаправленной или однонаправленной очереди узлы имеют ссылки на следующий элемент и предыдущий. Очереди всегда есть «хвост» и «голова». При удалении находит нужную ноду и отвязывает её меняя ссылки.

Основные методы в интерфейсе Queue (Java)
1.	add(E e): добавляет элемент в очередь. Если очередь заполнена, выбрасывает исключение.
2.	offer(E e): добавляет элемент в очередь. Возвращает false, если очередь заполнена, вместо выбрасывания исключения.
3.	remove(): удаляет и возвращает элемент из головы очереди. Если очередь пуста, выбрасывает исключение.
4.	poll(): удаляет и возвращает элемент из головы очереди. Возвращает null, если очередь пуста.
5.	element(): возвращает элемент из головы очереди без удаления. Если очередь пуста, выбрасывает исключение.
6.	peek(): возвращает элемент из головы очереди без удаления. Возвращает null, если очередь пуста.
      
Типы очередей
1.	Прямая очередь (FIFO):
      +	Элементы извлекаются в порядке добавления.
      +	Пример: LinkedList, ArrayDeque.
2.	Очередь с приоритетом (Priority Queue):
      +	Элементы извлекаются в порядке их приоритета, а не в порядке добавления.
      +	Пример: PriorityQueue.
3.	Двусторонняя очередь (Deque):
      +	Элементы могут добавляться и извлекаться как с начала, так и с конца.
      +	Пример: ArrayDeque, LinkedList.
4.	Блокирующая очередь (BlockingQueue):
      +	Потокобезопасная очередь, которая блокирует операции добавления или извлечения, если очередь заполнена или пуста.
      +	Пример: ArrayBlockingQueue, LinkedBlockingQueue.
      
Применение очередей

Очереди широко используются в программировании для решения различных задач:
1.	Организация задач в порядке поступления:
      +	Обработка запросов (например, в веб-серверах).
      +	Распределение задач между потоками.
2.	Буферы данных:
      +	Входной и выходной буфер при передаче данных.
3.	Алгоритмы поиска и обхода:
      +	Реализация обхода в ширину (BFS) в графах и деревьях.
4.	Система обработки событий:
      +	Очереди событий для игровых движков или GUI.
5.	Очереди с приоритетом:
      +	Планирование задач в операционных системах.
      +	Управление загрузкой задач в процессоре.
6.	Очереди сообщений:
      +	Используются в системах обмена данными между приложениями (например, Kafka, RabbitMQ).
### 26. Расскажите про интерфейсы Queue, Deque и их иерархию.
Иерархия интерфейсов
```java
Iterable
 └── Collection
      └── Queue
           └── Deque

```
+ Collection (основной интерфейс коллекций)
  + Queue (интерфейс для очередей)
    + Deque (интерфейс для двусторонних очередей)

Интерфейс Queue

+ Queue — это интерфейс, представляющий очередь (FIFO — First In, First Out), где элементы добавляются в конец и извлекаются из начала.

Основные характеристики:
+ Элементы обрабатываются в порядке их добавления.
+ Поддерживает добавление, удаление и просмотр элементов.

| Метод        | Описание                               | Бросает исключение | Возвращает `null` |
| ------------ | -------------------------------------- | ------------------ | ----------------- |
| `add(E e)`   | Добавляет элемент                      | ✅                  | ❌                 |
| `offer(E e)` | Добавляет элемент                      | ❌                  | ✅                 |
| `remove()`   | Удаляет и возвращает первый элемент    | ✅                  | ❌                 |
| `poll()`     | Удаляет и возвращает первый элемент    | ❌                  | ✅                 |
| `element()`  | Возвращает первый элемент без удаления | ✅                  | ❌                 |
| `peek()`     | Возвращает первый элемент без удаления | ❌                  | ✅                 |

Интерфейс Deque
+ Deque (двусторонняя очередь) расширяет Queue и предоставляет методы для работы с очередью с обеих сторон. Это значит, что элементы можно добавлять и удалять как с начала, так и с конца.

Основные характеристики:
+ Поддерживает поведение как FIFO (прямая очередь), так и LIFO (стек).
+ Элементы обрабатываются в порядке добавления, если не используются методы для добавления или удаления с конца.

Методы добавления

| Метод             | Описание                         |
| ----------------- | -------------------------------- |
| `addFirst(E e)`   | Добавить в начало                |
| `addLast(E e)`    | Добавить в конец                 |
| `offerFirst(E e)` | Добавить в начало без исключения |
| `offerLast(E e)`  | Добавить в конец без исключения  |

Методы удаления

| Метод           | Описание                         |
| --------------- | -------------------------------- |
| `removeFirst()` | Удалить из начала                |
| `removeLast()`  | Удалить из конца                 |
| `pollFirst()`   | Удалить из начала без исключения |
| `pollLast()`    | Удалить из конца без исключения  |

Методы просмотра

| Метод         | Описание                 |
| ------------- | ------------------------ |
| `getFirst()`  | Первый элемент           |
| `getLast()`   | Последний элемент        |
| `peekFirst()` | Первый без исключения    |
| `peekLast()`  | Последний без исключения |

Основные отличия Queue / Deque

| Критерий    | Queue       | Deque            |
|-------------| ----------- | ---------------- |
| Направление | Только FIFO | FIFO + LIFO      |
| Добавление  | В конец     | В начало и конец |
| Удаление    | С начала    | С начала и конца |
| Реализация  | LinkedList, PriorityQueue| LinkedList, ArrayDeque                |


### 27. В чем отличие метода poll() от remove()?

### 28. В чем отличие метода element() от peek()?

### 29. В чем отличие метода element() от poll()?

### 30. Перечислите наиболее часто используемые реализации интерфейса Queue.

### 31. Что такое ограниченные и неограниченные очереди?

### 32. Что такой односторонние и двусторонние очереди?

### 33. В чём отличие Deque от Queue?

### 34. В чём отличие методов removeLast() и pollLast()?

### 35. Назовите самую распространенную реализацию Deque.